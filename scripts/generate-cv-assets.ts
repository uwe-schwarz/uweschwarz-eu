import fs from "node:fs/promises";
import path from "node:path";
import { Buffer } from "node:buffer";
import { fileURLToPath } from "node:url";
import React from "react";
import ReactPDF from "@react-pdf/renderer";
import CVDocument from "./cv/CVDocument";
import { siteContent } from "../src/content/content";
import { generateCvDocx } from "./cv/CVDocumentDocx";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");
const publicDir = path.resolve(projectRoot, "public");

const languages: Array<"en" | "de"> = ["en", "de"];

const formatMonthYear = (date: Date, locale: string) =>
  date.toLocaleString(locale, { month: "long", year: "numeric" });

const buildLastUpdatedLabel = (date: Date) => ({
  en: `Last updated: ${formatMonthYear(date, "en-US")}`,
  de: `Letzte Aktualisierung: ${formatMonthYear(date, "de-DE")}`,
});

const resolveOutputName = (language: "en" | "de", extension: "pdf" | "docx", contentModTime: Date) => {
  const date = contentModTime.toISOString().split('T')[0]; // YYYY-MM-DD format
  return `uwe-schwarz-cv-${language}-${date}.${extension}`;
};

async function ensureDirectory(dir: string) {
  await fs.mkdir(dir, { recursive: true });
}

async function cleanupOldFiles(contentModTime: Date) {
  try {
    const files = await fs.readdir(publicDir);

    // Remove old CV files that don't match the current date
    const currentDate = contentModTime.toISOString().split('T')[0];
    const oldCvFiles = files.filter(file =>
      file.startsWith('uwe-schwarz-cv-') &&
      (file.endsWith('.pdf') || file.endsWith('.docx')) &&
      !file.includes(`-${currentDate}.`)
    );

    for (const file of oldCvFiles) {
      const filePath = path.join(publicDir, file);
      await fs.unlink(filePath);
      console.log(`Removed old CV file: ${file}`);
    }
  } catch (error) {
    console.warn('Failed to cleanup old files:', error);
  }
}

async function getFileModTime(filePath: string): Promise<Date | null> {
  try {
    const stats = await fs.stat(filePath);
    return stats.mtime;
  } catch {
    return null;
  }
}

async function shouldRegenerate(): Promise<{ shouldRegenerate: boolean; contentModTime: Date | null }> {
  const contentPath = path.resolve(projectRoot, "src/content/content.ts");
  const contentModTime = await getFileModTime(contentPath);

  if (!contentModTime) {
    console.log("Content file not found, regenerating...");
    return { shouldRegenerate: true, contentModTime: null };
  }

  for (const language of languages) {
    const pdfPath = path.join(publicDir, resolveOutputName(language, "pdf", contentModTime));
    const docxPath = path.join(publicDir, resolveOutputName(language, "docx", contentModTime));

    const pdfModTime = await getFileModTime(pdfPath);
    const docxModTime = await getFileModTime(docxPath);

    if (!pdfModTime || !docxModTime) {
      console.log(`CV files for ${language} not found, regenerating...`);
      return { shouldRegenerate: true, contentModTime };
    }

    if (contentModTime > pdfModTime || contentModTime > docxModTime) {
      console.log(`Content is newer than existing CV files for ${language}, regenerating...`);
      return { shouldRegenerate: true, contentModTime };
    }
  }

  console.log("CV files are up to date, skipping generation.");
  return { shouldRegenerate: false, contentModTime };
}

async function main() {
  const { shouldRegenerate: shouldRegen, contentModTime } = await shouldRegenerate();

  if (!shouldRegen) {
    return;
  }

  if (!contentModTime) {
    throw new Error("Content modification time is required for generation");
  }

  await ensureDirectory(publicDir);

  const profileImagePath = path.join(publicDir, "profile.jpg");
  const profileImage = await fs.readFile(profileImagePath);

  for (const language of languages) {
    const pdfElement = React.createElement(CVDocument, {
      language,
      data: siteContent,
      profileImageSrc: profileImage,
    });

    const pdfTarget = path.join(publicDir, resolveOutputName(language, "pdf", contentModTime));
    await ReactPDF.render(pdfElement, pdfTarget);

    const docxData = await generateCvDocx({
      language,
      data: siteContent,
      profileImage,
    });
    const docxTarget = path.join(publicDir, resolveOutputName(language, "docx", contentModTime));
    await fs.writeFile(docxTarget, Buffer.from(docxData));
  }

  console.log(
    `Generated CV assets: ${languages
      .map((lang) => `${resolveOutputName(lang, "pdf", contentModTime)}, ${resolveOutputName(lang, "docx", contentModTime)}`)
      .join("; ")}`
  );

  await cleanupOldFiles(contentModTime);

  // Generate a TypeScript file with the asset paths for the frontend
  const lastUpdatedLabel = buildLastUpdatedLabel(contentModTime);

  const cvAssetsContent = `// Auto-generated file - do not edit manually
// Generated by generate-cv-assets.ts based on content modification time

export const CV_ASSETS = {
  en: {
    pdf: "/${resolveOutputName("en", "pdf", contentModTime)}",
    docx: "/${resolveOutputName("en", "docx", contentModTime)}",
  },
  de: {
    pdf: "/${resolveOutputName("de", "pdf", contentModTime)}",
    docx: "/${resolveOutputName("de", "docx", contentModTime)}",
  },
} as const;

export const CV_LAST_UPDATED = {
  en: "${lastUpdatedLabel.en}",
  de: "${lastUpdatedLabel.de}",
} as const;
`;

  const cvAssetsPath = path.resolve(projectRoot, "src/generated/cv-assets.ts");
  await fs.mkdir(path.dirname(cvAssetsPath), { recursive: true });
  await fs.writeFile(cvAssetsPath, cvAssetsContent);

  console.log(`Generated CV assets configuration at ${cvAssetsPath}`);
}

main().catch((error) => {
  console.error("Failed to generate CV assets", error);
  process.exitCode = 1;
});
